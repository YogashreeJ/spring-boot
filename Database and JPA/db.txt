**JDBC vs Spring JDBC vs ORM vs JPA**

1ï¸âƒ£ Normal JDBC

Uses 7 steps (load driver, connection, statement, execute, result set, close, etc.)

Mostly written in repository (DAO) layer

High boilerplate code

Error-prone (manual resource management)

ğŸ“Œ Used rarely in modern applications

2ï¸âƒ£ Spring JDBC

Simplifies normal JDBC

Removes boilerplate (no manual connection / result set handling)

Uses JdbcTemplate

Still SQL-centric

Developer maps rows manually

ğŸ“Œ Better than JDBC, but still not ideal for complex apps

3ï¸âƒ£ ORM (Object Relational Mapping)

Technique to map:

Class â†’ Table

Fields â†’ Columns

Object â†’ Row

Eliminates manual SQL for CRUD

Works at object level, not table level

ğŸ“Œ ORM is a concept, not a framework

4ï¸âƒ£ ORM Tool â€“ Hibernate

Hibernate is an ORM implementation

Automatically:

Generates SQL

Maps objects â†” tables

Manages persistence lifecycle

Most popular ORM tool in Java ecosystem

ğŸ“Œ Hibernate â‰  JPA (important distinction)

5ï¸âƒ£ JPA (Java Persistence API)

Specification / standard, not an implementation

Defines:

Annotations (@Entity, @Id, etc.)

Rules for ORM behavior

ORM tools (Hibernate, EclipseLink) implement JPA

ğŸ“Œ Advantage:

Easy to switch ORM providers without changing much code

6ï¸âƒ£ Spring Data JPA

Spring abstraction on top of JPA

Uses ORM tools (usually Hibernate internally)

Eliminates DAO boilerplate

Provides:

JpaRepository

Built-in CRUD methods

Pagination, sorting, query methods

7. Working with H2 In-Memory Database

H2 is a lightweight in-memory database

Data is stored in RAM, not disk

Data is lost when the application stops

Mainly used for development and testing

ğŸ“Œ Advantage: No external DB setup required

8.@Entity Annotation

Marks a class as a JPA entity

Each entity maps to a database table

Class name becomes table name by default

Must have:

No-args constructor

Non-final class

ğŸ“Œ Managed by the persistence context

9.@Id Annotation

Marks the primary key of the entity

Each entity must have exactly one @Id

Used by JPA to uniquely identify records

ğŸ“Œ Often combined with @GeneratedValue

10.Changing H2 Username & Password (application.properties)
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.username=admin
spring.datasource.password=admin123

spring.h2.console.enabled=true
spring.h2.console.path=/h2-console


Default H2 username: sa

Password can be customized

Console helps inspect tables and data

ğŸ“Œ Used only in non-production environments

11.Built-in Methods from Spring Data JPA

By extending:

JpaRepository<Entity, ID>


You automatically get:

save()

findById()

findAll()

deleteById()

existsById()

count()

Pagination & sorting support

12.JPA Relationship -@OneToMany / @ManyToOne

OneToMany â†’ One entity owns many of another

ManyToOne â†’ Many entities belong to one entity

Always know which side owns the relationship (mappedBy)

13.fetch types
EAGER â†’ loads relationship immediately

LAZY â†’ loads relationship only when accessed

@OneToMany(fetch = FetchType.LAZY)
private List<Course> courses;
Why it matters:

LAZY avoids loading everything â†’ better performance

EAGER can trigger N+1 problem if not careful
Default fetch types: @ManyToOne â†’ EAGER, @OneToMany â†’ LAZY

14.N+1 Problem -Occurs when fetching one entity triggers multiple additional queries.Use JOIN FETCH to prevent N+1 problem

Example:List<Student> students = studentRepository.findAll();
for (Student s : students) {
    System.out.println(s.getCourses().size()); // triggers extra query per student!
}
 fix: use JOIN Fetch
 @Query("SELECT s FROM Student s JOIN FETCH s.courses")
List<Student> findAllWithCourses();

15.Pagination and sorting
1ï¸âƒ£ What is Pagination?

Pagination = fetching data in chunks (pages) instead of all at once.

ğŸ‘‰ Instead of returning 10,000 rows, you return:

Page 0 â†’ first 10 records

Page 1 â†’ next 10 records

Page 2 â†’ next 10 records

Why pagination is important

ğŸš€ Performance (less DB load)

ğŸ’¾ Less memory usage

ğŸŒ Faster API response

â“ Amazon interview favorite: â€œHow do you handle large datasets?â€

2ï¸âƒ£ What is Sorting?

Sorting = ordering the results based on a field.

Examples:

Sort students by name

Sort by createdAt DESC

Sort by marks ASC

Sorting is usually combined with pagination.

3ï¸âƒ£ Pageable Object (VERY IMPORTANT)

Pageable is an interface provided by Spring Data.

It contains:

Page number

Page size (records per page)

Sorting info

You donâ€™t create it directly â€” Spring creates it for you.

Example (Controller)
@GetMapping("/students")
public Page<Student> getStudents(Pageable pageable) {
    return studentRepository.findAll(pageable);
}


Now the client can call:

/students?page=0&size=5&sort=name,asc

4ï¸âƒ£ PageRequest (Concrete Implementation)

PageRequest is a class that implements Pageable.

Syntax
PageRequest.of(pageNumber, pageSize)

Example
Pageable pageable = PageRequest.of(0, 10);
Page<Student> page = studentRepository.findAll(pageable);

5ï¸âƒ£ Pagination + Sorting Together
Pageable pageable = PageRequest.of(
        0,
        5,
        Sort.by("name").ascending()
);


OR descending:

Sort.by("createdAt").descending()

6ï¸âƒ£ Page vs List (Interview GOLD)
Page<Student> page = studentRepository.findAll(pageable);


Page gives you:

getContent() â†’ actual data

getTotalElements() â†’ total records

getTotalPages() â†’ total pages

isFirst() / isLast()

ğŸ‘‰ Amazon likes Page over List

7ï¸âƒ£ Page Number Gotcha âš ï¸

Page numbers are ZERO-based

page = 0 â†’ first page

page = 1 â†’ second page

Many students mess this up in interviews.

8ï¸âƒ£ One-Line Interview Answer ğŸ§ 

Pagination is used to retrieve data in chunks to improve performance, and sorting orders that data based on one or more fields.
Spring Data JPA provides Pageable and PageRequest to handle both efficiently.



