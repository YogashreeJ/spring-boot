Spring Security ‚Äì Core Notes (Interview + Real World)
1Ô∏è‚É£ What happens when you add Spring Security dependency?

The moment you add:

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-security</artifactId>
</dependency>


Spring Boot auto-configures security and:

Secures ALL endpoints

Enables form login

Enables HTTP Basic

Creates one default user

Adds a security filter chain

üëâ Result: Every API returns 401 / login page unless authenticated.

2Ô∏è‚É£ Spring Security Filter Chain (MOST IMPORTANT)

Spring Security works using Servlet Filters.

üîπ Request Flow
Client Request
   ‚Üì
Security Filter Chain
   ‚Üì
DispatcherServlet
   ‚Üì
Controller


If authentication/authorization fails ‚Üí request never reaches controller.

3Ô∏è‚É£ Important Security Filters (in order ‚Äì interview favorite)

You don‚Äôt need to remember exact order, but you must know roles.

1. SecurityContextPersistenceFilter

Loads SecurityContext at request start

Stores it back at request end

Reads from HTTP Session

üìå This is how Spring remembers who is logged in

2. UsernamePasswordAuthenticationFilter

Handles login requests

Default URL: /login

Reads:

username

password

Creates Authentication object

Used for form login

3. BasicAuthenticationFilter

Handles HTTP Basic Auth

Reads Authorization: Basic xxx

Common in REST APIs

4. AuthenticationFilter

Delegates authentication to:

AuthenticationManager

AuthenticationProvider

5. AnonymousAuthenticationFilter

If user not logged in ‚Üí assigns anonymous user

Prevents null authentication

6. ExceptionTranslationFilter

Handles security exceptions

Converts them to:

401 (Unauthorized)

403 (Forbidden)

7. FilterSecurityInterceptor

Authorization happens here

Checks:

Roles

Authorities

Access rules

üìå This is where:

hasRole("ADMIN")


is enforced.

4Ô∏è‚É£ How password is generated by default?

When you run the app, Spring prints this in console:

Using generated security password: 3f9a8d72-9c33-4b7c-9c90-xxxx

Why?

Spring Boot auto-creates:

username: user
password: random UUID

How?

Internally:

Uses UserDetailsService

Creates an in-memory user

Password is encoded using BCrypt

5Ô∏è‚É£ How password is stored internally?

Passwords are NEVER stored as plain text

Spring uses:

PasswordEncoder (BCryptPasswordEncoder)


Example:

$2a$10$ZpX7M... (hashed)


During login:

Raw password ‚Üí hashed

Compared with stored hash

6Ô∏è‚É£ How session is maintained?
üîπ On successful login

Authentication succeeds

SecurityContext is created

Stored in:

HttpSession

üîπ Next request

Session ID sent via cookie

SecurityContextPersistenceFilter retrieves user

User stays logged in

üìå This is stateful authentication

7Ô∏è‚É£ How to set custom username & password (3 ways)
‚úÖ Way 1: application.properties (basic)
spring.security.user.name=admin
spring.security.user.password=admin123
spring.security.user.roles=ADMIN


üìå Only for testing / learning

‚úÖ Way 2: In-memory user (recommended for interviews)
@Configuration
public class SecurityConfig {

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.builder()
                .username("yoga")
                .password(passwordEncoder().encode("amazon123"))
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

‚úÖ Way 3: Database-based user (real world)

Flow:

Controller ‚Üí AuthenticationManager
 ‚Üí UserDetailsService
 ‚Üí DB


You implement:

@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Override
    public UserDetails loadUserByUsername(String username) {
        User user = userRepo.findByUsername(username);

        return new org.springframework.security.core.userdetails.User(
                user.getUsername(),
                user.getPassword(),
                List.of(new SimpleGrantedAuthority("ROLE_USER"))
        );
    }
}

8Ô∏è‚É£ Quick interview one-liners (Amazon style)

Spring Security is filter-based, not interceptor-based

Authentication happens before controller

Authorization is done by FilterSecurityInterceptor

Passwords are stored using BCrypt hashing

Session stores SecurityContext

Default user is created via auto-configuration